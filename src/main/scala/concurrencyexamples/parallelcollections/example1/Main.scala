package concurrencyexamples.parallelcollections.example1

/*
  Еще одним удобным способом параллельной обработки
 */

object Main extends App {

  val list = List(1, 2, 3, 4, 5, 6, 7, 8)

  // последовательная обработка
  list.map(x => x * 2).filter(x => x < 10).map(x => x + 1)

  // параллельная обработка
  list.par.map(x => x * 2).filter(x => x < 10).map(x => x + 1)

}

/*
  Плюсы:
  + Один из самых удобных способов параллельной обработки данных
  Минусы:
  - Подходит далеко не всегда
 */

/*
  Какие есть еще варианты?
  - Thread, Mutex, SpinLock - и прочие примитивные средства параллелизма и синхронизации
  - Software Transcational Memory - концепция, представляющая все изменения памяти как транзакции.
  Если транзакции мешают друг другу, то происходит откат транзакций. Этот подход является популярным в Clojure и Haskell
  - Akka-streams - Высокоуровневая абстракция над акторами. Создается граф обработки действий.
  На каждый узел такого графа создается по актору.
 */